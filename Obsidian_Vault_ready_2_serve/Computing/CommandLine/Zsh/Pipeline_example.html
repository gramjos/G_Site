<p>---</p>
<p>tags:</p>
<p>- zsh</p>
<p>- pipe</p>
<p>- pipeline</p>
<p>- linux</p>
<p>- command_cut</p>
<p>- command_column</p>
<p>- command_grep</p>
<p>- history_substitution_operator</p>
<p>- standard_error</p>
<p>- redirection</p>
<p>---</p>
<h5>Demonstrative pipe example</h5>
<img src="graphics/pipeline_example.png" alt="" loading="lazy" decoding="async" />
<p>Above is the partial output of the command `$ ls /bin /usr/bin`. These are the binary executables in the file system.</p>
<p>Say, we wanted to remove the white text.</p>
<p>`$ ls /bin /usr/bin |grep -v '/bin:$'`</p>
<p>**Aside**, `:` (colon) is a literal colon and is not a meta-character.</p>
<p>The `-v` or `--invert-match` means, everything that does not match the grep string will be printed to standard out.</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell"> $ ls /bin /usr/bin |grep -v &#39;/bin:$&#39;
[
bash
cat
chmod
cp
csh
dash
date
...
test
unlink
wait4path
zsh
...
AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader 
IOSDebug
ResMerger 
...</code></pre>
</div>
<p>The above snippet is partial output from the command. Notice the ellipsis. The pesky newline after the `zsh` line is apart of the real output. Lets remove that line by a new pipe and a `grep`</p>
<p>`$ ls /bin /usr/bin |grep -v '/bin:$'|grep -v '^$'`</p>
<p>Understanding the regex: `'^$'`</p>
<p>`^` starting at the beginning of the line then match _nothing_ til the end of the line `$`. In tandem with the `-v` option this will output all the lines that do not match a blank line.</p>
<p>###### `column`_ize_ the output</p>
<p>given `proglist`, a file of the all the available commands defined as...</p>
<p>`$ /bin/ls /bin /usr/bin | grep -v '/bin:$' | grep -v '^$' | sort > proglist`</p>
<p>`$ cat proglist`</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-">AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader
IOSDebug
ResMerger
...</code></pre>
</div>
<p>The above is partial output. Notice the ellipsis.</p>
<p>`$ column proglist`</p>
<p>when given with no options will pick how many columns based off the current terminal size (the width of the window).</p>
<p>`$ column -c 50 proglist`</p>
<p>the `-c` option will output columns based on the hardcoded specifications of a terminal window being 50 columns wide.</p>
<p>###### `cut`ing off excess characters</p>
<p>`$ head proglist | cut -c 1-7`</p>
<p>__Aside__, `head` outputs the first ten lines. Then, `cut` based off characters (`-c`). The above command outputs the first 7 characters of each line.</p>
<p>**Oops** I mean to get the fist 9 characters, not 7. Perfect time for the **history substitution operator** `^n^n`</p>
<p>`$ ^7^9`</p>
<p>###### Get all programs (lines) that end in 'sh'</p>
<p>`$ grep 'sh$' proglist`</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-">afhash
bash
chsh
crlrefresh
csh
dash
hash
instmodsh
ksh
mcxrefresh
power_report.sh
sh
ssh</code></pre>
</div>
<p>Modify the above command so that the commands that end in '.sh' are omitted. Good use case for `egrep` that accepts extended regular expressions. `grep -E` is the same as `egrep`.</p>
<p>`$ egrep '[^.]sh$' proglist`</p>
<p>###### Conditional or in egrep's regex</p>
<p>`$ egrep '[^.]sh$|ch$' proglist`</p>
<p>The above command shows the regex or conditional which happens to be a pipe as well! A conditional and is achieved by separating out the conditions in different passes of the `grep` command. Yes, multiple pipelines of `grep` are necessary to achieve this.</p>
<p>###### `ls` (list) the contents of each directory in the `PATH`</p>
<p>Given, the below command will outputs the paths in an arguments friendly way.</p>
<p>`$ echo ${PATH}|tr ':' ' '`</p>
<p>**translate** the characters from standard input. Specifically, for replace every colon with a space. Then with **command substitution** we put the standard output of the command on the command line as arguments (not through pipes as standard input). **Command substitution** is done with backticks. Think of it as an in-place substitution.</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">$ ls `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`</code></pre>
</div>
<p>###### Alternative with loops</p>
<p>See more in <a href="/notes/computing/commandline/zsh/loops">Loops</a></p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">for dir in  `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`
do
	ls $dir
done</code></pre>
</div>
<p>###### Got errors?</p>
<p>Redirect to the standard error to the 'waste bin' (`/dev/null`)</p>
<p>Direct the '2' stream (file descriptor) to standard error. Modify the `ls` line with the below.</p>
<p>`ls $dir 2> /dev/null`</p>
<p>######  More robust script will only call `ls` on directories</p>
<p>A simple check (`test`) before the call to `ls` will suffice.</p>
<p>The above for loop naively calls `ls` on everything in the `PATH`. Lets make sure the for variable is a directory before calling `ls`</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">for dir in  `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`
do
	if [ -d $dir ]
	then
		ls $dir
	fi
done</code></pre>
</div>