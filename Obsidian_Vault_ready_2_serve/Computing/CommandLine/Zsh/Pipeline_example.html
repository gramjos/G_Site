<p>---</p>
<p>tags:</p>
<p>- zsh</p>
<p>- pipe</p>
<p>- pipeline</p>
<p>- linux</p>
<p>- command_cut</p>
<p>- command_column</p>
<p>- command_grep</p>
<p>- history<em>substitution</em>operator</p>
<p>- standard_error</p>
<p>- redirection</p>
<p>---</p>
<h5>Demonstrative pipe example</h5>
<img src="graphics/pipeline_example.png" alt="" loading="lazy" decoding="async" />
<p>Above is the partial output of the command <code class="inline-code">$ ls /bin /usr/bin</code>. These are the binary executables in the file system.</p>
<p>Say, we wanted to remove the white text.</p>
<p><code class="inline-code">$ ls /bin /usr/bin |grep -v &#39;/bin:$&#39;</code></p>
<p>**Aside**, <code class="inline-code">:</code> (colon) is a literal colon and is not a meta-character.</p>
<p>The <code class="inline-code">-v</code> or <code class="inline-code">--invert-match</code> means, everything that does not match the grep string will be printed to standard out.</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell"> $ ls /bin /usr/bin |grep -v &#39;/bin:$&#39;
[
bash
cat
chmod
cp
csh
dash
date
...
test
unlink
wait4path
zsh
...
AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader 
IOSDebug
ResMerger 
...</code></pre>
</div>
<p>The above snippet is partial output from the command. Notice the ellipsis. The pesky newline after the <code class="inline-code">zsh</code> line is apart of the real output. Lets remove that line by a new pipe and a <code class="inline-code">grep</code></p>
<p><code class="inline-code">$ ls /bin /usr/bin |grep -v &#39;/bin:$&#39;|grep -v &#39;^$&#39;</code></p>
<p>Understanding the regex: <code class="inline-code">&#39;^$&#39;</code></p>
<p><code class="inline-code">^</code> starting at the beginning of the line then match <em>nothing</em> til the end of the line <code class="inline-code">$</code>. In tandem with the <code class="inline-code">-v</code> option this will output all the lines that do not match a blank line.</p>
<p>###### <code class="inline-code">column</code><em>ize</em> the output</p>
<p>given <code class="inline-code">proglist</code>, a file of the all the available commands defined as...</p>
<p><code class="inline-code">$ /bin/ls /bin /usr/bin | grep -v &#39;/bin:$&#39; | grep -v &#39;^$&#39; | sort &gt; proglist</code></p>
<p><code class="inline-code">$ cat proglist</code></p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-">AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader
IOSDebug
ResMerger
...</code></pre>
</div>
<p>The above is partial output. Notice the ellipsis.</p>
<p><code class="inline-code">$ column proglist</code></p>
<p>when given with no options will pick how many columns based off the current terminal size (the width of the window).</p>
<p><code class="inline-code">$ column -c 50 proglist</code></p>
<p>the <code class="inline-code">-c</code> option will output columns based on the hardcoded specifications of a terminal window being 50 columns wide.</p>
<p>###### <code class="inline-code">cut</code>ing off excess characters</p>
<p><code class="inline-code">$ head proglist | cut -c 1-7</code></p>
<p><strong>Aside</strong>, <code class="inline-code">head</code> outputs the first ten lines. Then, <code class="inline-code">cut</code> based off characters (<code class="inline-code">-c</code>). The above command outputs the first 7 characters of each line.</p>
<p>**Oops** I mean to get the fist 9 characters, not 7. Perfect time for the **history substitution operator** <code class="inline-code">^n^n</code></p>
<p><code class="inline-code">$ ^7^9</code></p>
<p>###### Get all programs (lines) that end in 'sh'</p>
<p><code class="inline-code">$ grep &#39;sh$&#39; proglist</code></p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-">afhash
bash
chsh
crlrefresh
csh
dash
hash
instmodsh
ksh
mcxrefresh
power_report.sh
sh
ssh</code></pre>
</div>
<p>Modify the above command so that the commands that end in '.sh' are omitted. Good use case for <code class="inline-code">egrep</code> that accepts extended regular expressions. <code class="inline-code">grep -E</code> is the same as <code class="inline-code">egrep</code>.</p>
<p><code class="inline-code">$ egrep &#39;[^.]sh$&#39; proglist</code></p>
<p>###### Conditional or in egrep's regex</p>
<p><code class="inline-code">$ egrep &#39;[^.]sh$|ch$&#39; proglist</code></p>
<p>The above command shows the regex or conditional which happens to be a pipe as well! A conditional and is achieved by separating out the conditions in different passes of the <code class="inline-code">grep</code> command. Yes, multiple pipelines of <code class="inline-code">grep</code> are necessary to achieve this.</p>
<p>###### <code class="inline-code">ls</code> (list) the contents of each directory in the <code class="inline-code">PATH</code></p>
<p>Given, the below command will outputs the paths in an arguments friendly way.</p>
<p><code class="inline-code">$ echo ${PATH}|tr &#39;:&#39; &#39; &#39;</code></p>
<p>**translate** the characters from standard input. Specifically, for replace every colon with a space. Then with **command substitution** we put the standard output of the command on the command line as arguments (not through pipes as standard input). **Command substitution** is done with backticks. Think of it as an in-place substitution.</p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">$ ls `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`</code></pre>
</div>
<p>###### Alternative with loops</p>
<p>See more in <a href="/notes/computing/commandline/zsh/loops">Loops</a></p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">for dir in  `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`
do
	ls $dir
done</code></pre>
</div>
<p>###### Got errors?</p>
<p>Redirect to the standard error to the 'waste bin' (<code class="inline-code">/dev/null</code>)</p>
<p>Direct the '2' stream (file descriptor) to standard error. Modify the <code class="inline-code">ls</code> line with the below.</p>
<p><code class="inline-code">ls $dir 2&gt; /dev/null</code></p>
<p>######  More robust script will only call <code class="inline-code">ls</code> on directories</p>
<p>A simple check (<code class="inline-code">test</code>) before the call to <code class="inline-code">ls</code> will suffice.</p>
<p>The above for loop naively calls <code class="inline-code">ls</code> on everything in the <code class="inline-code">PATH</code>. Lets make sure the for variable is a directory before calling <code class="inline-code">ls</code></p>
<div class="code-wrapper">
    <button class="copy-btn">Copy Code</button>
    <pre><code class="language-shell">for dir in  `echo ${PATH}|tr &#39;:&#39; &#39; &#39;`
do
	if [ -d $dir ]
	then
		ls $dir
	fi
done</code></pre>
</div>